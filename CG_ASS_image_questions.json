[
    {
        "id": "2022a05",
        "question": [
            {
                "type": "text",
                "text": "Given are the vertices (labelled in the image)\nconst int numVertices=8;\nconst float vertices[numVertices][2] = {{100,100},{400,100},{100,200},{400,200},{100,300},{400,300},{100,400},{400,400}};\nWhich of the following represents a possible indices array that will generate the image shown below if we use the OpenGL commands glBegin(GL_TRIANGLES) and glEnd()?"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022a05.jpg"
                }
            },
            {
                "type": "text",
                "text": "a. None of the others.\nb. {0, 1, 2, 0, 3, 2, 0, 5, 2, 0, 7, 2, 1, 4, 3, 1, 6, 3, 4, 5, 7, 4, 7, 6}\nc. {0, 1, 2, 3, 4, 5, 6, 7}\nd. {4, 5, 7, 4, 7, 6, 0, 1, 3, 0, 3, 2, 0, 5, 7, 0, 7, 2, 4, 1, 3, 4, 3, 6}\ne. {0, 1, 3, 0, 3, 2, 1, 3, 4, 4, 3, 6, 4, 6, 7, 4, 7, 5, 7, 2, 5, 7, 0, 5}"
            }
        ]
    },
    {
        "id": "2022a10",
        "question": [
            {
                "type": "text",
                "text": "Consider the following image of a sphere:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022a10.jpg"
                }
            },
            {
                "type": "text",
                "text": "Assuming a scene where the light intensities and reflection coefficients for ambient, diffuse, and specular are non-zero, which types of reflection are enabled for this scene?\na. Ambient, Diffuse, and Specular\nb. Diffuse only\nc. Ambient and Diffuse\nd. Diffuse and Specular\ne. Ambient Only"
            }
        ]
    },
    {
        "id": "2022a15",
        "question": [
            {
                "type": "text",
                "text": "Write a function drawGrid(), that generates the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022a15.jpg"
                }
            },
            {
                "type": "text",
                "text": "Your function should have the following signature:\nvoid drawGrid(double width, double height)\nThe grid consists of rows/columns of squares that span the x-z plane, with each square being made up of two triangles. The width parameter gives the number of of squares the grid contains on the x-axis, and the height parameter gives the number of squares the grid contains on the z-axis.\nEach square is exactly one unit wide on both the x and z axes.\nThe y axis value of each vertex is derived from its location on the x and z axes. The y-axis value is equal to the cosine (in radians) of the x-axis value + the cosine (in radians) of the z-axis value.\nYou must use GL_TRIANGLES to draw the mesh. You do not need to specify vertex colours.\nThe vertices must be given in anticlockwise order for the triangles as seen from above. In each pair of triangles, the triangle closer to the origin must be drawn starting from the closest vertex to the origin (minimum x and z), and the triangle farther away from the origin must be drawn starting from the farthest vertex from the origin (maximum x and z).\nThe grid should fill in each column (each group of height tiles that share x-axis values) before proceeding to the next column.\nThe image above shows the grid drawn in wireframe. You do not need to specify that drawing will be done in wireframe.\nYou can assume that if required, you have access to a Vector3 class that represents a 3D vector, and exposes fields named x, y, and z.\nYou can assume that you have access to standard trigonometric functions such as cos(), and that they assume input parameters are in radians by default.\nImportant note:\nCoderunner requires certain OpenGL functions to use special versions:\nInstead of glVertex3d(), use CRVertex3d()"
            }
        ]
    },
    {
        "id": "2022a16",
        "question": [
            {
                "type": "text",
                "text": "Write a function projectVertex(), that computes the projection of a vertex on to a plane for the purpose of creating a shadow.\nThe plane is given in the form ax + by + cz + d = 0\nYour function should have the following signature:\nVector3 projectVertex(Vector3 vertex, double a, double b, double c, double d)\nThe function should return the location of a vertex given by the vertex parameter when projected from the origin on to a plane given by the a, b, c,  & d parameters.\nIf working correctly, the program will produce the following output:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022a16.jpg"
                }
            },
            {
                "type": "text",
                "text": "You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z.\nYour code can assume that this is a straightforward case for generating shadows: the light source (the origin of the projection) is located at (0, 0, 0), and you do not need to account for any transformations on the object.\nYou do not need to handle the actual display of the object or the shadow, only the calculation of the shadow vertex location."
            }
        ]
    },
    {
        "id": "2022a17",
        "question": [
            {
                "type": "text",
                "text": "Write a function phongDirectionalSource() which implements the achromatic version of the Phong Illumination equation for a directional light source.\nIf the function is implemented correctly you should get the following result (Note: this image is rendered using only your implementation and does not use OpenGL lights or materials)"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022a17.jpg"
                }
            },
            {
                "type": "text",
                "text": "Your function should have the following signature:\ndouble phongDirectionalSource(double ambientIntensity, double diffuseIntensity, double specularIntensity, double ambientReflecCoef, double diffuseReflecCoef, double specularReflecCoef, double shininess, Vector3 pointOnSurface, Vector3 surfaceNormal, Vector3 incomingLightDirection, Vector3 viewPoint)\nA Vector3 class representing a 3D vector is available to you, with the following member functions:\nVector3 Vector3::normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3::magnitude() //returns the length of the vector\nvoid Vector3::normalize() //normalises the vector (destructive)\nIn addition, you can assume the + and - operators are available for the Vector3 class.\nYou can assume that the following functions are also defined:\ndouble dot(Vector3 a, Vector3 b) //returns the dot product of a and b\nVector3 cross (Vector3 a, Vector3 b) //returns the cross product of a and b\ndouble pow(double a, double b) //returns a to the power of b\nHint: The parameter incomingLightDirection refers to the direction of travel of light rays emitted from the light source."
            }
        ]
    },
    {
        "id": "2022b07",
        "question": [
            {
                "type": "text",
                "text": "The image below on the left is used to texture map a rectangle as illustrated in the image below on the right. Assume the bottom-left vertex of the rectangle has the texture coordinates (2, 1) and that the texture parameter GL_REPEAT is set for both texture coordinate directions.\nWhat are the texture coordinates of the other three vertices?\nNOTE: the texture coordinate of the bottom-left vertex is (2,1) and not (0,0)!"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b07.jpg"
                }
            },
            {
                "type": "text",
                "text": "Select one:\na. Bottom-right vertex: (-2, 1); Top-left vertex: (2, 2.5); Top-right vertex: (-2, 2.5)\nb. Bottom-right vertex: (4, 0); Top-left vertex: (0, 1.5); Top-right vertex: (4, 1.5)\nc. Bottom-right vertex: (-4, 0); Top-left vertex: (0, 1.5); Top-right vertex: (-4, 1.5)\nd. Bottom-right vertex: (-4, 1); Top-left vertex: (0, 2.5); Top-right vertex: (-4, 2.5)\ne. Bottom-right vertex: (6, 1.5); Top-left vertex: (2, 2.5); Top-right vertex: (6, 2.5)"
            }
        ]
    },
    {
        "id": "2022b08",
        "question": [
            {
                "type": "text",
                "text": "The texture image below on the left is mapped onto a triangle producing  the picture below on the right."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b08.jpg"
                }
            },
            {
                "type": "text",
                "text": "Assumed the texture is repeated in both coordinate directions and the texture coordinate of the bottom left vertex is (0, 0).\nWhat are the texture coordinates at the top-left and top-right vertex of the triangle?\nSelect one:\na. The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 0).\nb. The texture coordinate of the top-left vertex is (1, 0) and of the top-right vertex (3, 0).\nc. The texture coordinate of the top-left vertex is (1, 0) and of the top-right vertex (0, 3).\nd. The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (0, 3).\ne. The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 1)."
            }
        ]
    },
    {
        "id": "2022b15",
        "question": [
            {
                "type": "text",
                "text": "Given is a function drawShape() which draws a wireframe representation of the letter \"L\" in the xy-plane as shown in the image below."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b15-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "Please write OpenGL code to transform this shape such that you obtain the scene displayed in the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b15-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "IMPORTANT:\nPlease only use OpenGL transformations, e.g. glScalef, glTranslatef, glRotatef\nPlease do NOT draw the shape itself - this is done automatically by the uploaded code"
            }
        ]
    },
    {
        "id": "2022b16",
        "question": [
            {
                "type": "text",
                "text": "Given is a function drawShape() which draws a wireframe representation of the letter \"F\" in the xy-plane as shown in the image below."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b16-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "Please write OpenGL code to transform this shape such that you obtain the scene displayed in the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b16-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "IMPORTANT:\nPlease only use OpenGL transformations, e.g. glScalef, glTranslatef, glRotatef\nPlease do NOT draw the shape itself - this is done automatically by the uploaded code"
            }
        ]
    },
    {
        "id": "2022b17",
        "question": [
            {
                "type": "text",
                "text": "Given is an RGB colour cube with side length 2 as illustrated in the image below\""
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b17-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "Please write OpenGL code to rotate this cube as illustrated in the image below."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b17-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "IMPORTANT:\nPlease only use OpenGL transformations, e.g. glTranslatef, glRotatef\nPlease do NOT draw the shape itself - this is done automatically by the uploaded code"
            }
        ]
    },
    {
        "id": "2022b18",
        "question": [
            {
                "type": "text",
                "text": "Given is a function drawTorus() which draws a torus with coloured \"blobs\" centered at the origin and aligned with the z-axis as shown in the image below."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b18-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "Please write OpenGL code to render the the chain of tori displayed in the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b18-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "Note that the second torus is rotated such that it lies in the xz-plane and has a centre of (1.5, 0, 0), and the third torus lies again in the zy-plane and has a centre of (0, 1.5, 0).\nIMPORTANT:\nYour code must first draw the torus centered at the origin, then the torus centered at (1.5, 0, 0), and then the torus centered at (0, 1.5, 0). Your code should have the format:\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\nYou can use any OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix;"
            }
        ]
    },
    {
        "id": "2022b19",
        "question": [
            {
                "type": "text",
                "text": "The image below is used to texture map a rectangle:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b19-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "The texture mapping code to be used is:\nglBegin(GL_QUADS);\nglTexCoord2f(0,2);\nglVertex3f(0,0,0);\nglTexCoord2f(A,C);\nglVertex3f(6,0,0);\nglTexCoord2f(A,B);\nglVertex3f(6,4,0);\nglTexCoord2f(0,B);\nglVertex3f(0,4,0);\nglEnd();\nand produces the image shown below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b19-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "Please copy and paste the following code to define the correct values for the variables A, B and C, i.e.\nA=<Your Answer>;\nB=<Your Answer>;\nC=<Your Answer>;"
            }
        ]
    },
    {
        "id": "2022b20",
        "question": [
            {
                "type": "text",
                "text": "The image below is used to texture map a square:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b20-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "The texture mapping code to be used is:\nglBegin(GL_QUADS);\nglTexCoord2f(0.0,0.5);\nglVertex3f(0,0,0);\nglTexCoord2f(A,B);\nglVertex3f(4,0,0);\nglTexCoord2f(C,D);\nglVertex3f(4,4,0);\nglTexCoord2f(E,F);\nglVertex3f(0,4,0);\nglEnd();\nand produces the image shown below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b20-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "Please use the following code to define the correct values for the variables A, B, C, D, E, F. NOTE: The texture coordinates must be between 0 and 1. Write the correct values into the answer space using C/C++ notation.\nA=?;\nB=?;\netc."
            }
        ]
    },
    {
        "id": "2022b21",
        "question": [
            {
                "type": "text",
                "text": "In this exercise you need to complete the function below defining an intersection between a Ray and a convex quadrilateral with circular hole. The convex quadrilateral (and its circular hole) lie on a plane with the normal n. The quadrilateral is defined by four vertices A, B, C and D, and the circular hole by its centre and radius.\nComplete the template in the answer space for the function for computing the intersection between a ray and a quadrilateral with a circular hole. You can use the algorithms explained in the lecture slide and/or use any of your solutions of the graded and ungraded CodeRunner quizzes.\nNOTE: A point is inside a convex quadrilateral, if it lies on the same side of all edges when traversing the edges in clockwise or anti-clockwise order. We can hence use the same inside-outside test as for the triangle, except that we have four instead of three edges.\ndouble QuadWithCircleHole::Intersect(Vector source, Vector d)\n{\n\t// complete calculation of ray-quadrilateral-with-circular-hole intersection in the answer box below\n\t// and return correct value for t. If there is no intersection t should be -1.0\n}\nNote: The following variables and functions are already defined for you to use:\nVector A, B, C, D - coordinates of the 4 vertices of the convex quadrilateral in winding order (either clockwise or anti-clockwise)\nVector n - normal of the plane of the quadrilateral\nVector Centre - centre of the circular hole\ndouble radius - radius of the circular hole\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nYou can compute the length of a vector v as \"sqrt(v.Dot(v))\"\nPlease paste the completed code fragment into the answer space. If your solution is correct you should get the following image (note: the quadrilateral is the green surface at the bottom and the circular hole appears blue (since we can see the background colour through it):"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b21.jpg"
                }
            }
        ]
    },
    {
        "id": "2022b22",
        "question": [
            {
                "type": "text",
                "text": "Given is a cubic spline curve c(t)=T M G with the geometric constraint vector\nG=(p0, p1, r0, r0.5)^T\nThe curve c(t) is defined by the four conditions c(0)=p0 (start point), c(1)=p1 (end point), c'(0)=r0 (start tangent), and c'(0.5)=r0.5 (mid-point tangent).\nImplement this curve by computing its basis functions and completing the code fragment below.\nTIP: You can use the same idea we used in the lecture to derive the basis functions of the Hermite curve.\nNote that in order to get the basis functions you need to invert a 4x4 matrix.\nThis is easiest done by using an online tool such as:\nhttps://www.wolframalpha.com/calculators/matrix-inverse-calculator\nPlease write your answer into the answer space using the following format:\ndouble Basis1(double t){ return <Insert code>;} // B1(t) \ndouble Basis2(double t){ return <Insert code>;} // B2(t) \ndouble Basis3(double t){ return <Insert code>;} // B3(t)\ndouble Basis4(double t){ return <Insert code>;} // B4(t)\nCVec3df c(float t, CVec3df p0, CVec3df p1, CVec3df r0, CVec3df r05) { \n   CVec3df p=<Insert code>; \n   return p; \n}\nThe first test case uses the geometric constraints\np0.setVector(4, 0, 0);      // This is p0\np1.setVector(0, 0, 3);      // This is p1\nr0.setVector(-10, 10, 0);   // This is r0\nr05.setVector(0, 0, 10);    // This is r05\nand should result in the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2022b22.jpg"
                }
            }
        ]
    },
    {
        "id": "2023a17",
        "question": [
            {
                "type": "text",
                "text": "Given are the vertices\nconst int numVertices=9;\nconst float vertices[numVertices][2] = { {100,50},{300,50},{150,150},{250,150},{50,200},{150,200},{250,200},{350,200},{200,300} };\nWhich calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023a17.jpg"
                }
            },
            {
                "type": "text",
                "text": "Write OpenGL code for drawing the shape. You can assume that the following function is defined:\nvoid v(int i) {glVertex2fv(vertices[i]);}\nYour code should have the following form:\nglBegin(GL_TRIANGLE_FAN);\nv(<start_index>); // draw first vertex\n// draw as many additional vertices as necessary using the above format\nglEnd();\nIMPORTANT:\n1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape. The vertices must be defined in clockwise order.\nIf you get the correct image but an error in the test case then this might indicate that you used anticlockwise order, or that your first vertex index is not correct, or that you have drawn more vertices than necessary."
            }
        ]
    },
    {
        "id": "2023a18",
        "question": [
            {
                "type": "text",
                "text": "Given are the vertices\nconst int numVertices=8;\nconst float vertices[numVertices][2] = {{50,50},{100,50},{200,50},{250,50},{50,300},{100,300},{200,300},{250,300} };\nWhich calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_STRIP) and glEnd()?"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023a18.jpg"
                }
            },
            {
                "type": "text",
                "text": "Write OpenGL code for drawing the shape. You can assume that the following function is defined:\nvoid v(int i) {glVertex2fv(vertices[i]);}\nYour code should have the following form:\nglBegin(GL_TRIANGLE_STRIP);\nv(<start_index>); // draw first vertex\n// draw as many additional vertices as necessary using the above format\nglEnd();\nIMPORTANT:\n1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape.  Do not repeat any vertices. Note that some triangles are allowed to slightly overlap.\nIf you get the correct image but an error in the test case then this might indicate that your first vertex index is not correct, or that you have drawn more vertices than necessary."
            }
        ]
    },
    {
        "id": "2023a21",
        "question": [
            {
                "type": "text",
                "text": "Phong Shading interpolates the surface normal of a polygon and computes the perceived colour of each pixel using the Phong Illumination model. In OpenGL this is usually implemented using so-called fragment shaders.\nIn order to apply Phong shading to a triangle we need to interpolate the normals at the vertices of the triangle. In this exercise you will implement a function barycentricInterpolation, which interpolates the normals of a triangle for a given point p on the triangle. The signature of the function is:\nCVec3df barycentricInterpolation(CVec3df p, CVec3df p0, CVec3df p1, CVec3df p2, CVec3df n0, CVec3df n1, CVec3df n2)\nThe point p is a point on the triangle. The vertices of the triangle are p0, p1, and p2, and the corresponding normals are n0, n1, and n2. The function returns the interpolated normal at the point p. The interpolation must be performed using barycentric interpolation as discussed in the lecture.\nAfter completing this function you should get the following output:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023a21.jpg"
                }
            },
            {
                "type": "text",
                "text": "NOTE 1:\nYou can use the function\ndouble areaTriangle(CVec3df p0, CVec3df p1, CVec3df p2)\nwhich returns the area of the triangle defined by three points p0, p1 and p2.\nNOTE 2:\nThe class CVec3df implements a 3D vector as a 3D array. The class defines operations for adding two vectors and scaling vectors, e.g.:\nCVec3df a,b,c;\nc=a+b;\nc=5.0*a;\ndouble xCoor=a[0];    // x-coordinate\ndouble yCoor=a[1];    // y-coordinate\ndouble zCoor=a[2];    // z-coordinate"
            }
        ]
    },
    {
        "id": "2023a22",
        "question": [
            {
                "type": "text",
                "text": "Given is a triangle with the vertices:\nconst int numVertices=3;\nconst float vertices[numVertices][2] = {{-50,0},{50,0},{0,120}};\nThe triangles has a width of 100 and a height of 120 and is oriented along the y-axis.\nUse this triangle to draw a sun / flower shape as shown in the images below. The given program draws a red circle with centre (250, 250) and radius 100. Please draw n triangles around this red circle in anti-clockwise direction starting with the triangle at the top. To place the triangles around the red circle they are transformed as follows:\n1) The triangle given above is translated by 100 in y-direction\n2) The i-th triangle is rotated by i/n*360 degree around the origin. For example, if n=4 then the first triangle is rotated by 0 degree, the second by 90 degree, the third by 180 degree, and the fourth by 270 degree.\n3) Translate the rotated triangle by 250 in x- and y-direction\nIMPORTANT:\n1) The number n of triangles is  given by the variable numTriangles. Please do not change it.\n2) Please draw the n triangles in anti-clockwise order starting with the triangle at the top (0 degree rotation). Each triangle is drawn using GL_TRIANGLES and the vertex order 0, 1, 2\n3) You are not allowed to use OpenGL transformations, i.e., you need to compute the transformed vertices before you draw them. You can use the functions cos(x) and sin(x).  Note that these functions use an argument in radian. In order to use an angle in degree you can write: cos(2*PI*angleInDegree/360.0f)\nNote that the constant PI is already predefined.\n4) Note that if two arguments are integers C/C++ uses integer division, e.g. 7/3=2. In order to get floating point division one of the arguments must be a floating point number, e.g., 7.0f/3 or ((float) 7)/3\n5) Please draw the transformed vertices using the function\nmyVertex2D(float x, float y)\nwhich calls the corresponding glVertex command and outputs information for the automarker.\nThe image below shows the expected output for n=4, n=8, and n=20."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023a22.jpg"
                }
            }
        ]
    },
    {
        "id": "2023b02",
        "question": [
            {
                "type": "text",
                "text": "Given is a 3D medical imaging data set of a head which specifies for each point the radiodensity of the material, i.e., to what extend the material blocks x-rays. For example, bone has a higher value (is less transmissible) than muscle, skin, and fluid. What surface representation is most suitable for rendering the bone layer of the head as illustrated in the image below?"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b02.jpg"
                }
            },
            {
                "type": "text",
                "text": "Select one:\na. Parametric surfaces\nb. CSG (Constructive Solid Geometry)\nc. Subdivision surfaces\nd. Implicit surfaces\ne. First using a CGS object and then smoothing it using a subdivision surface."
            }
        ]
    },
    {
        "id": "2023b07",
        "question": [
            {
                "type": "text",
                "text": "Given are the following vertices:\nconst int numVertices=7;\nconst float vertices[numVertices][2] = { {50,50},{300,50},{50,150},{50,200},{200,200},{50,300},{300,300} };\nConsider the image shown below."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b07.jpg"
                }
            },
            {
                "type": "text",
                "text": "Which calling sequence of these vertices (using glVertex2fv) results in the shape in the image above, if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?\nSelect one:\na. 4, 1, 0, 2, 3, 5, 6\nb. 6, 1, 0, 2, 4, 3, 5\nc. 0, 1, 2, 3, 4, 5, 6\nd. 4, 3, 5, 6, 1, 0, 2\ne. 1, 0, 2, 4, 3, 5, 6"
            }
        ]
    },
    {
        "id": "2023b09",
        "question": [
            {
                "type": "text",
                "text": "Given is a function drawHouse() which draws a wire frame house in the xy-plane as shown in the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b09.jpg"
                }
            },
            {
                "type": "text",
                "text": "We now transform the house in two different ways before drawing it:\nDrawing 1:\nglScalef(2.0, 1.0, 1.0);\ndrawHouse();\nDrawing 2:\nglScalef(2.0, 1.0, -1.0);\ndrawHouse();\nWhich of the following statements is correct?\nSelect one:\na. The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.\nb. The two drawings look different, and the MODEL_VIEW matrices used to transform the house before drawing are different.\nc. The two drawings look the same, and the MODEL_VIEW matrices used to transform the house before drawing are the same.\nd. The transformation is not possible (generates an error).\ne. The two drawings look different, but the MODEL_VIEW matrices used to transform the house before drawing are the same."
            }
        ]
    },
    {
        "id": "2023b12",
        "question": [
            {
                "type": "text",
                "text": "Given is the following texture image:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b12-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "What texture coordinates do we need to specify if we want to use this texture image to create the textured triangle shown below?"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b12-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "Select one:\na. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nb. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (1.0, 0.0)\nTexture coordinates for the top vertex of the triangle: (1.0, 1.0)\nc. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nd. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.75)\nTexture coordinates for the bottom-right vertex of the triangle: (0.5, 0.5)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\ne. Texture coordinates for the bottom-left vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 1.0)\nTexture coordinates for the top vertex of the triangle: (0.0, 0.5)"
            }
        ]
    },
    {
        "id": "2023b13",
        "question": [
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b13.jpg"
                }
            },
            {
                "type": "text",
                "text": "Select one:\na. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 3)\nTexture coordinate for P7: (4, 3)\nTexture coordinate for P8: (6, 3)\nTexture coordinate for P9: (2, 4)\nTexture coordinate for P10: (6, 4)\nb. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (1, 0.5)\nTexture coordinate for P5: (2, 0.5)\nTexture coordinate for P6: (1, 1.5)\nTexture coordinate for P7: (2, 1.5)\nTexture coordinate for P8: (3, 1.5)\nTexture coordinate for P9: (1, 2)\nTexture coordinate for P10: (3, 2)\nc. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 2)\nTexture coordinate for P7: (4, 2)\nTexture coordinate for P8: (6, 2)\nTexture coordinate for P9: (2, 3)\nTexture coordinate for P10: (6, 3)\nd. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (2, 0.5)\nTexture coordinate for P5: (4, 0.5)\nTexture coordinate for P6: (2, 1.5)\nTexture coordinate for P7: (4, 1.5)\nTexture coordinate for P8: (6, 1.5)\nTexture coordinate for P9: (2, 2)\nTexture coordinate for P10: (6, 2)\ne. None of the others."
            }
        ]
    },
    {
        "id": "2023b16",
        "question": [
            {
                "type": "text",
                "text": "Given is a profile curve c(t)=(x(t), 0, z(t)), 0 \u2264 t \u2264 1, which lies in the xz-plane. The resulting surface-of-revolution is shown in the image below. What is the parametric equation of the profile curve indicated in blue in the image below?"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b16.jpg"
                }
            },
            {
                "type": "text",
                "text": "Select one:\n$$a. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$b. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$c. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$d. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$e. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-0.5*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+1 \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$"
            }
        ]
    },
    {
        "id": "2023b17",
        "question": [
            {
                "type": "text",
                "text": "What is the parametric equation of the donut-shaped surface p(t)=(x(s,t), y(s,t), z(s,t)), 0 \u2264 s,t \u2264 1 shown in the image below?\nHint 1: The surface is a surface-of-revolution as discussed in the lecture. The profile curve is an ellipsoid shown in the image below in blue."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b17.jpg"
                }
            },
            {
                "type": "text",
                "text": "Select one:\na. p(t)=\n$$\\begin{pmatrix} (1.5*cos(2 \\pi t) + 2.5) cos (2 \\pi s) \\\\ (1.5*cos(2 \\pi t) + 2.5) sin (2 \\pi s) \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nb. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) +2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s)  \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nc. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) + 2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s) +2.5 \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nd. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$\ne. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) + 2.5 \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$"
            }
        ]
    },
    {
        "id": "2023b20",
        "question": [
            {
                "type": "text",
                "text": "A plane n.p=d defines a half-space, where the half space are all points where n.p<=d.\nFor example, for the plane x=0 the half space are all points with an x-coordinate <=0.\nUsing this definition we can now define a \"cut-sphere\" as the intersection of a sphere S and a half-space defined by the plane P. I.e., the \"cut-sphere\" contains all points which are inside the sphere and inside the half-space defined by P. The image below shows an example."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b20.jpg"
                }
            },
            {
                "type": "text",
                "text": "Which of the statements below about the ray intersection with a \"cut-sphere\" (defined by a sphere S and a plane P) is false?\nNOTE: You can assume that the \"cut-sphere\" is in front of the eye point.\nSelect one:\na. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the \"cut-sphere\" is equal to the first intersection point with the sphere S.\nb. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object does not exist (i.e., the intersection of the sphere and half-space is empty).\nc. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object is equal to the sphere S (i.e., the intersection of the sphere and half-space is the sphere and nothing gets cut off.).\nd. The surface normal of a cut-sphere is either the normal of the sphere S or the normal of the plane P dependent on where the ray intersects the \"cut-sphere\" first.\ne. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P after it intersects the sphere S, then the intersection point with the \"cut-sphere\" is given by the intersection point with the sphere S."
            }
        ]
    },
    {
        "id": "2023b30",
        "question": [
            {
                "type": "text",
                "text": "Given is an RGB colour cube with side length 2 as illustrated in the image below\""
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b30-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "Please write OpenGL code to transform the cube as shown in the image below. The cube should be scaled by 2 in z-direction, the face with the black, green, blue and cyan vertex should form an angle of 70 degree with the yz-plane, and the edge from black to blue should be parallel to the z-axis with a distance of 2 and should lie on the yz-plane."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b30-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "IMPORTANT:\nPlease only use OpenGL transformations, e.g. glTranslatef, glRotatef\nPlease do NOT draw the cube itself - this is done automatically by the uploaded code"
            }
        ]
    },
    {
        "id": "2023b31",
        "question": [
            {
                "type": "text",
                "text": "Given is a function drawTorus() which draws a torus with colored \"blobs\" centred at the origin and aligned with the z-axis as shown in the image below."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b31-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "Please write OpenGL code to render the two tori displayed in the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b31-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "Note that the first torus lies on the xy-plane with centre (1, 1, 0), and the second  torus lies on the yz-plane with centre (0, 1, 1).\nIMPORTANT:\nYour code must draw the tori in the order described above. Your code should have the format:\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\nNote: transformations refers to OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix"
            }
        ]
    },
    {
        "id": "2023b32",
        "question": [
            {
                "type": "text",
                "text": "Write a function animateBouncyBall(), which takes as parameters the position p of a ball and its velocity v and a plane in dot-normal form given by n (unit normal) and d. The function updates the ball's position and velocity for one animation step. Your function should have the following signature:\nvoid animateBouncyBall(Vector3& p, Vector3& v, Vector3& n, double& d)\nNote: The \"&\" symbol represents a reference variable, i.e., any change to this variable will be visible outside the function. You can use it like a normal variable of type Vector3.\nYou can assume that the ball's position p is initially on the outside of the plane (the side the normal points to). Your function should update p such that its new value is p+v and the velocity v stays unchanged. However, if the new point p+v is on the other side of the plane, then you must reflect the vector v on the plane and the new velocity is v_reflected and the new point is p+v_reflected.\nNote: You can ignore that the point p is not exactly on the plane when reflected.\nThe image below illustrates how the position and velocity of the ball change if the function animateBouncyBall() is called multiple times."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b32.jpg"
                }
            },
            {
                "type": "text",
                "text": "You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:\ndouble dot(Vector3 u, Vector3 v) //dot product\nVector3 cross(Vector3 u, Vector3 v) //cross product\nYou can assume that the Vector3 class has the following member functions available to you:\nVector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3.magnitude() //returns the length of the vector\nYou can assume that the Vector3 class supports the following operators returning an object of type Vector3:\nVector3 + Vector3\nVector3 - Vector3\nVector3 * double // Note: the order is important, the scalar has to come after the vector when multiplying\nFor example:\nTest1\nVector3 n=Vector3(1, 0, 0); // plane unit normal\ndouble d=0;                 // plane distance from origin\nVector3 p = Vector3(0.5, 0.0, 0.0);\nVector3 v = Vector3(-0.2, 0.0, 0.0);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nResult1\nposition=(0.50,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.10,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(0.20,0.00,0.00)\nposition=(0.50,0.00,0.00) velocity=(0.20,0.00,0.00)"
            }
        ]
    },
    {
        "id": "2023b33",
        "question": [
            {
                "type": "text",
                "text": "In this question we want to create the front and right side of the texture mapped muesli box shown in the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b33-1.jpg"
                }
            },
            {
                "type": "text",
                "text": "The 3D model uses a quadstrip for the front and right side and a quadrilateral for the top side, which are textured using the texture image below. Note that the sections of the texture image used for the front and right side of the box are rectangular (illustrated in green in the image below) and the section of the texture image used for the top side of the box is a trapezoid (illustrated in blue in the image below)."
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b33-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "Please only use the texture coordinates indicated in the image above in order to define the missing values for s1, s2, s3, s4, s5 and t1, t2, t3 in the code shown in the answer box. Please do not change anything else.\nTemplate code:\ns1 = 0;  // please replace with the correct texture coordinate \ns2 = 0;  // please replace with the correct texture coordinate  \ns3 = 0;  // please replace with the correct texture coordinate \ns4 = 0;  // please replace with the correct texture coordinate \ns5 = 0;  // please replace with the correct texture coordinate \nt1 = 0;  // please replace with the correct texture coordinate  \nt2 = 0;  // please replace with the correct texture coordinate \nt3 = 0;  // please replace with the correct texture coordinate \n// front and right face face\nglBegin(GL_QUAD_STRIP);\nglTexCoord2f(s1, t1);\nglVertex3f(0, 0, 0.7);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t1);\nglVertex3f(2, 0, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s3, t1);\nglVertex3f(2, 0, 0);\nglTexCoord2f(s3, t2);\nglVertex3f(2, 4, 0);\nglEnd();\n// top face\nglBegin(GL_QUADS);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s5, t3);\nglVertex3f(2, 4, 0);\nglTexCoord2f(s4, t3);\nglVertex3f(0, 4, 0);\nglEnd();"
            }
        ]
    },
    {
        "id": "2023b34",
        "question": [
            {
                "type": "text",
                "text": "Given is a cubic spline curve c(t)=T M G with the geometric constraint vector\nG=(p0, p1, p2, p3)^T\nThe basis matrix of the spline curve is\n$$\\bf{M}=\\begin{pmatrix} -4.5 & 13.5 & -13.5 & 4.5 \\\\ 9 & -22.5 & 18 & -4.5$$\n$$\\\\ -5.5 & 9 & -4.5 & 1 \\\\ 1 & 0 & 0 & 0 \\end{pmatrix}$$\nThe spline curve is used as profile curve for a surface-of-revolution.\nImplement this curve by defining its basis functions and completing the code fragment below.\nPlease write your answer into the answer space using the following format:\ndouble Basis1(double t){ return <Insert code>;} \ndouble Basis2(double t){ return <Insert code>;}\ndouble Basis3(double t){ return <Insert code>;} \ndouble Basis4(double t){ return <Insert code>;} \nCVec3df curve(float t)\n{\n  // return the curve point c(t) of type CVec3df   \n}\nThe first test case uses the geometric constraints:\nconst CVec3df p0(1, 0, 0);\nconst CVec3df p1(1.6666, 0, 0.2);\nconst CVec3df p2(2.3333, 0, 1.5);\nconst CVec3df p3(3, 0, 1);\nand should result into the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b34.jpg"
                }
            },
            {
                "type": "text",
                "text": "You can assume that the CVec3df class supports the following operators returning an object of type CVec3df:\nCVec3df + CVec3df\nCVec3df * double // Note: the order is important, the scalar has to come after the vector when multiplying"
            }
        ]
    },
    {
        "id": "2023b36",
        "question": [
            {
                "type": "text",
                "text": "In this exercise you need to complete the function below defining a Ray-CutSphere Intersection:\ndouble CutSphere::Intersect(Vector source, Vector d)\nNOTE: The pre-loaded answer box contains already code for the ray sphere intersection and sorts the intersection points such that t1 is the first intersection point with the original sphere.\nAdd additional code such that the function returns instead the intersection points with the \"cut-sphere\".\nThe cutting plane n.p=a is defined by the variables n (type Vector) and a (type double).\nHINT: Compute the ray-plane intersection and develop an algorithm to decide whether the ray intersects the round (un-cut part) of the sphere, the cutting plane, or doesn't intersect the cut sphere at all (e.g. the ray might pass through the cut-off part of the sphere)\nIMPORTANT: If the ray first intersects the cutting plane of the cut sphere (the flat part of it) then you need to set cuttingPlaneIntersected = true; . This is used in the normal calculation and without the automarker will mark your solution as false.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nAfter completing the code in the pre-loaded answer box you should get the images below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b36-1.jpg"
                }
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b36-2.jpg"
                }
            },
            {
                "type": "text",
                "text": "Template code:\ndouble CutSphere::Intersect(Vector source, Vector d)\n{\n\t// A, B, and C are the parameters of quadratic equation for finding the \n\t// ray intersection parameter t (see slide 16 of the \"Ray Tracing\" lecture notes)\n\tfloat A = d.Dot(d);\n\tfloat B = 2 * source.Dot(d);\n\tfloat C = source.Dot(source) - 1;\n\tfloat t; // the parameter t for the closest intersection point or ray with the sphere. If no intersection t=-1.0\n\t// BEGIN SOLUTION RAY-SPHERE INTERSECTION\n\tif (B * B - 4 * A * C <= 0) return t=-1;  // no hit\n\tfloat t1;\n\tif (B > 0)   // for numerical precision\n\t\tt1 = (-B - sqrt(B * B - 4 * A * C)) / (2 * A);\n\telse\n\t\tt1 = (-B + sqrt(B * B - 4 * A * C)) / (2 * A);\n\tfloat t2 = C / (A * t1); // easier way to get t2\n\t// END SOLUTION RAY-SPHERE INTERSECTION\n\t// if t1>t2 swap, so t1 is always first intersection point\n\tfloat temp;\n\tif (t1 > t2) {\n\t\ttemp = t1;\n\t\tt1 = t2;\n\t\tt2 = temp;\n\t}\n\tt = t1;\n\tcuttingPlaneIntersected = false; // variable of type bool - true if ray first intersects the flat part of the cut sphere\n\t// ===================================================================\n\t// == The above method code computes the intersection parameters of ==\n\t// == the ray with the sphere. Add additional code such that the    ==\n\t// == function returns instead the intersections points with the    ==\n\t// == \"cut-sphere\".                                                 ==\n\t// == Tip: Compute the ray-plane interscetion and develop an        ==\n\t// ==      algorithm to decide whether the ray intersected the      ==\n\t// ==      round (un-cut part) of the sphere, the cutting plane,    ==\n\t// ==      or doesn't intersect the cut spere at all (e.g. the ray  ==\n\t// ==      might pass through the cut-off part of the sphere        ==\n    // == IMPORTANT: If the ray first intersects the cutting plane of   ==\n\t// ==            the cut sphere (the flat part of it) then you need ==\n\t// ==            to set cuttingPlaneIntersected = true;             ==\n\t// ==            This is used in the normal calculation and without ==\n\t// ==            the automarker will mark your solution as false    ==\n\t// ===================================================================\n    // Please complete the missing code\n\treturn t;\n}"
            }
        ]
    },
    {
        "id": "2023b37",
        "question": [
            {
                "type": "text",
                "text": "In this exercise you need to complete the normal calculation for the Ray-CutSphere Intersection from the previous question. Note that you can complete this question even if you were unable to implement the intersection function correctly.\nPlease implement the function\nVector CutSphere::Normal(Vector p)\nNOTE: The function should return the correct normal of the \"cut: unit sphere at the ray intersection point p. Note that the cut-sphere is a unit sphere with centre at the origin. The normal of the cutting plane is n (type Vector).\nNOTE 2: You can assume that the boolean variable cuttingPlaneIntersected is defined and that it is true if p lies on the flat part of the \"cut\" unit sphere and false otherwise.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nVector v.Normalize() - returns the normalised version of the vector v\nAfter completing the code in the pre-loaded answer box you should get the image below:"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": "https://raw.githubusercontent.com/TFPlusPlus/GPT-4V-vs.-CG/main/CG_Assessments_Images/2023b37.jpg"
                }
            }
        ]
    }
]